
'''
#og lcm
#p,q=int(61),int(53)
def lcm(p,q):
    
    #from p import p as prime
    from p import p24 as prime
    sp,sq=prime(p),prime(q)
    #return sp,sq,sq+[a for a in sp if a not in sq]
    ans=sq+[a for a in sp if a not in sq]
    s=int(1)
    for a in ans:
        s*=a
    return s
    
    #or just
    import math
    return p*q/math.gcd(p,q)
'''
#lcm made repeatable
def lcm(p,*q):
    import math
    for x in q:
        p=p*x//math.gcd(p,x)
    return p

#Carmichael's totient function


'''
#og gcd
def gcd(p,q):
    
    #from p import p as prime
    from p import p24 as prime
    sp,sq=prime(p),prime(q)
    #return sp,sq,sq+[a for a in sp if a not in sq]
    ans=[a for a in sp if a in sq]
    s=int(1)
    for a in ans:
        s*=a
    return s
    
    #or just
    import math
    return math.gcd(p,q)
'''
#gcd made repeatable
def gcd(b,*a):
    import math
    for x in a:
        b=math.gcd(b,x)
    return b

#modular multiplicative inverse
#d?*e=1mod(a)
#413*17=1mod(780)

#a=int(870)
#e=int(17)
def mmi(a,e):
    k=int(a//e+1)
    b=k*e-a
    #print(k,b)
    t=int(b)
    for c in range(1,e):
        
        if t%e==1:
            o=int(t//e)
            break
        t+=b
        #print(b,c,t%e)
    d=k*(c)-o
    #break
    return d#,' * ',e,' = 1 (mod ',a,')',(d*e,a*c,(d*e)-(a*c),((d*e)-(a*c))//e,((d*e)-(a*c))%e)

#print(d,' * ',e,' = 1 (mod ',a,')')
#print(d*e,a*c,(d*e)-(a*c),((d*e)-(a*c))//e,((d*e)-(a*c))%e)
#print(a//e,a%e)


#Extended Euclidean algorithm
#eea(17,780,1)
#413*17-9*780=1    413*17=1mod(780)
def eea(a,e,r): #r as gcd
    s=[[1,0],[0,1]]
    n=int(1)
    difp,diff=a,e
    rem=int(difp%diff)
    #while rem!=r or s[-1][0] <0:
    for x in range(30):
        #print(rem,s[-1][0 if a>e else 1])
        if rem==r and s[-1][0]>0: break
        n+=1
        #c=int(difp//diff)
        c=int((difp-1)//diff)
        #print(difp,diff,c)
        #print(rem,s)
        #rem=int(difp%diff)
        rem=int((difp-1)%diff+1)
        s+=[[s[n-2][0]-c*s[n-1][0],s[n-2][1]-c*s[n-1][1]]]
        #print(rem,s[n])
        
        if r!=1 and rem==1:
            print('dig')
            s[-1]=[r*x for x in s[-2]]
            rem=r
            break
        difp=diff
        diff=rem
    #print(rem,s)
    return s[-1]




#encryption
def c(m):
    return m**e%n

#decryption
#private keys d,n=413,3233
def m(c):
    return c**d%n

if __name__ == '__main__':
    
    import time
    start=time.time()
    i=lcm(49,18,56)
    from p import p24 as prime
    print(i,prime(i))
    #print(gcd(420,120,2000,360))
    #print(eea(17,11,2))
    #eea(240,46,2)
    #print(eea(46,240,2))
    #print(eea(240,46,2))
    #print(eea(780,17,1))#8*780=367*17+1
    #print(eea(17,780,1))413*17=9*780+1
    #print(mmi(780,17))
    
    
    '''
    p,q=61,53
    n,e=p*q,17 #public key
    
    a=lcm(p-1,q-1)
    #d=mmi(a,e)
    d=eea(e,a,1)[0]
    message=2840
    crypt=c(message)
    dcode=m(crypt)
    print(crypt,dcode)
    
    print(time.time()-start)
    '''




